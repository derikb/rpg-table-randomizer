{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/index_noname.js","src/randomizer.js","src/random_table.js","src/table_normalizer.js","src/random_name.js","src/r_helpers.js","src/npc.js"],"names":["randomizer","require","random_table","table_normalizer","random_name","r_helpers","npc_gen","module","exports","RandomTable","TableNormalizer","npc_generator","Randomizer","arraySum","arr","total","i","length","v","parseFloat","isNaN","parseDiceNotation","die","number","modifier","mod_op","parseInt","sum","this","random","Math","round","_this4","token_types","min","max","floor","getWeightedRandom","values","weights","n","num","call","rollRandom","data","Array","isArray","forEach","k","l","_typeof","weight","push","label","props","Object","keys","getTableResult","rtable","start","_this","isObject","table","result","desc","isEmpty","macro","t","getTableByKey","niceString","sequence","tables","selectFromTable","seq","r","isString","concat","times","_this2","o","result_print","isUndefined","find","t_result","findToken","key","subtable","r2","kx","description","convertToken","token","curtable","parts","replace","split","string","_this3","regexp","RegExp","newstring","roll","trim","m","match","setTableKeyLookup","lookup","registerTokenType","name","process","token_parts","full_token","multiplier","indexOf","x","config","id","title","author","source","tags","initialize","prop","hasOwnProperty","default","validate","properties","error","fields","general","field","message","simple","print_opt","print","hide_table","capitalize","hide_result","hide_desc","outputObject","editmode","att","JSON","parse","stringify","outputCode","compress","obj","findObject","findResultElem","orig_data","normalized_data","data_type","setData","checkType","e","substring","parseHtml","html","text","ct","parseText","parseMarkdown","normalizeData","type","parse_data","namedata","generateList","name_type","create","names","male","female","gender","ceil","createName","selectName","style","options","holmesname","demonname","capitalizeName","selectSurname","mkey","lastname","thename","markov","memory","MarkovGenerator","order","namelist","learn","skey","generate","leave_lower","upper_parts","map","w","join","scount","holmesian_scount","holmesian_syllables","toLowerCase","holmesian_title","toUpperCase","format","demonic","registerNameType","surname","separator","txt","mem","breakText","value","seed","genInitial","cur_key","step","state","ret","nextAvailable","next","getRandomValue","nextState","slice","cb","prev","shift","toString","charAt","NPC","Base","prototype","schema","helpers","schema_fields","Schemas","f","sch","src_temp","func","Function","count","set","p","registerSchema","constructor","default_","undefined","h","bind","apply","_toConsumableArray"],"mappings":"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","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n\nconst randomizer = require('./randomizer.js');\nconst random_table = require('./random_table.js');\nconst table_normalizer = require('./table_normalizer.js');\nconst random_name = require('./random_name.js')(randomizer);\nconst r_helpers = require('./r_helpers.js');\nconst npc_gen = require('./npc.js')(randomizer);\n\nmodule.exports = {\n\trandomizer: randomizer,\n\tRandomTable: random_table,\n\tTableNormalizer: table_normalizer,\n\trandom_name: random_name,\n\tr_helpers: r_helpers,\n\tnpc_generator: npc_gen\n};\n\n","'use strict';\n\nconst r_helpers = require('./r_helpers.js');\n\n/**\n * Randomizer - handles app randomization functions\n * Module exports a single instance of Randomizer...\n * @constructor\n */\nconst Randomizer = function () {\n\t/**\n\t * Store the token types/processing\n\t */\n\tthis.token_types = {};\n\t/**\n\t * Random integer between two numbers (stolen from underscorejs)\n\t * @param {Number} min mininum value\n\t * @param {Number} max maximum value\n\t * @return {Number} random value\n\t */\n\tthis.random = function (min, max) {\n\t\tif (max == null) {\n\t\t\tmax = min;\n\t\t\tmin = 0;\n\t\t}\n\t\treturn min + Math.floor(Math.random() * (max - min + 1));\n\t};\n\t/**\n\t * Sum an array\n\t * @param {Array} arr an array of numbers\n\t * @returns {Number} Total value of numbers in array\n\t */\n\tfunction arraySum (arr) {\n\t\tlet total = 0;\n\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\tconst v = parseFloat(arr[i]);\n\t\t\tif (!isNaN(v)) {\n\t\t\t\ttotal += v;\n\t\t\t}\n\t\t}\n\t\treturn total;\n\t};\n\t/**\n\t * Random value selection\n\t * @param {Array} values an array of strings from which to choose\n\t * @param {Array} weights a matching array of integers to weight the values (i.e. values and weights are in the same order)\n\t * @returns {String} the randomly selected Array element from values param\n\t */\n\tthis.getWeightedRandom = function (values, weights) {\n\t\tlet n = 0;\n\t\tconst num = this.random(1, arraySum.call(this, weights));\n\t\tfor (var i = 0; i < values.length; i++) {\n\t\t\tn = n + weights[i];\n\t\t\tif (n >= num) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn values[i];\n\t};\n\t/**\n\t * Random value selection, wrapper for getWeightedRandom that processes the data into values/weights arrays\n\t * @param {Object|Array} data An object or array of data\n\t * @returns {String} the randomly selected Object property name, Array element, or value of the \"label\" property\n\t */\n\tthis.rollRandom = function (data) {\n\t\tconst values = [];\n\t\tconst weights = [];\n\t\t\t\n\t\tif (Array.isArray(data)) {\n\t\t\tdata.forEach((v, k, l) => {\n\t\t\t\tif (typeof v === 'object') {\n\t\t\t\t\tif (typeof v.weight !== 'undefined') {\n\t\t\t\t\t\tweights.push(v.weight);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tweights.push(1);\n\t\t\t\t\t}\n\t\t\t\t\tvalues.push(v.label);\n\t\t\t\t} else if (typeof v === 'string') {\n\t\t\t\t\t// nothing\n\t\t\t\t\tweights.push(1);\n\t\t\t\t\tvalues.push(v);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (typeof data === 'object' && data !== null) {\n\t\t\tconst props = Object.keys(data);\n\t\t\tprops.forEach((k) => {\n\t\t\t\tconst v = data[k];\n\t\t\t\tif (typeof v.weight !== 'undefined') {\n\t\t\t\t\tweights.push(v.weight);\n\t\t\t\t} else {\n\t\t\t\t\tweights.push(1);\n\t\t\t\t}\n\t\t\t\tvalues.push(k);\n\t\t\t});\n\t\t}\n\t\treturn this.getWeightedRandom(values, weights);\n\t};\n\t/**\n\t * Dice rolling simulator\n\t * @param {Number} [die=6] Die type\n\t * @param {Number} [number=1] Number of times to roll the die\n\t * @param {Number} [modifier=0] Numeric modifier to dice total\n\t * @param {String} [mod_op=+] Operator for the modifier (+,-,/,*)\n\t * @returns {Number} Number rolled (die*number [mod_op][modifier])\n\t */\n\tfunction parseDiceNotation (die, number, modifier, mod_op) {\n\t\tmodifier = (typeof modifier === 'undefined') ? 0 : parseInt(modifier, 10);\n\t\tdie = (typeof die === 'undefined') ? 6 : parseInt(die, 10);\n\t\tmod_op = (typeof mod_op === 'undefined') ? '+' : mod_op;\n\n\t\tif (typeof number === 'undefined' || number === 0) {\n\t\t\tnumber = 1;\n\t\t} else {\n\t\t\tnumber = parseInt(number, 10);\n\t\t}\n\t\t\n\t\tlet sum = 0;\n\t\tfor (let i = 1; i <= number; i++) {\n\t\t\tsum = sum + this.random(1, die);\n\t\t}\n\t\tif (modifier === 0) {\n\t\t\treturn sum;\n\t\t}\n\t\t\n\t\tswitch (mod_op) {\n\t\t\tcase '*':\n\t\t\t\tsum = sum * modifier;\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tsum = sum - modifier;\n\t\t\t\tbreak;\n\t\t\tcase '/':\n\t\t\t\tsum = sum / modifier;\n\t\t\t\tbreak;\n\t\t\tcase '+':\n\t\t\tdefault:\n\t\t\t\tsum = sum + modifier;\n\t\t\t\tbreak;\n\t\t}\n\t\treturn Math.round(sum);\n\t};\n\t/**\n\t * Generate a result from a RandomTable object\n\t * @param {Object} rtable the RandomTable\n\t * @param {String} [start=''] subtable to roll on\n\t * @return {Array} array of object results { table: table that was rolled on, result: result string, desc: optional description string }\n\t */\n\tthis.getTableResult = function (rtable, start) {\n\t\tif (!r_helpers.isObject(rtable)) {\n\t\t\treturn [{ table: 'Error', result: 'No table found to roll on.', desc: '' }];\n\t\t}\n\t\tlet result = [];\n\t\tif (typeof start === 'undefined') {\n\t\t\tstart = '';\n\t\t}\n\t\t\n\t\t// if macro is set then we ignore a lot of stuff\n\t\tif (!r_helpers.isEmpty(rtable.macro)) {\n\t\t\t// iterate over the tables and get results\n\t\t\trtable.macro.forEach((t) => {\n\t\t\t\tconst table = this.getTableByKey(t);\n\t\t\t\tif (r_helpers.isEmpty(table)) { return; }\n\t\t\t\tthis.getTableResult(table);\n\t\t\t\tresult.push({ table: t, result: table.niceString() });\n\t\t\t});\n\t\t\trtable.result = result;\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\t// we look in the start table for what to roll if the start wasn't explicitly set in the call\n\t\tlet sequence = (start === '') ? rtable.sequence : start;\n\t\t\n\t\tif (sequence === 'rollall') {\n\t\t\t// roll all the tables in order\n\t\t\tsequence = Object.keys(rtable.tables);\n\t\t}\n\t\t\n\t\tif (sequence === '') {\n\t\t\t// if no start attribute\n\t\t\t// try for \"default\" table\n\t\t\tif (typeof rtable.tables['default'] !== 'undefined') {\n\t\t\t\tresult = this.selectFromTable(rtable, 'default');\n\t\t\t} else {\n\t\t\t\t// select first item from tables\n\t\t\t\tconst tables = Object.keys(rtable.tables);\n\t\t\t\tresult = this.selectFromTable(rtable, tables[0]);\n\t\t\t}\n\t\t} else if (typeof sequence === 'string') {\n\t\t\tresult = this.selectFromTable(rtable, sequence);\n\t\t} else {\n\t\t\tsequence.forEach((seq) => {\n\t\t\t\tlet r = '';\n\t\t\t\tif (r_helpers.isString(seq)) {\n\t\t\t\t\tr = this.selectFromTable(rtable, seq);\n\t\t\t\t\tresult = result.concat(r);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// its an object\n\t\t\t\tconst table = (seq.table) ? seq.table : '';\n\t\t\t\tif (table === '') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst times = (typeof seq.times === 'number') ? seq.times : 1;\n\t\t\t\tfor (let i = 1; i <= times; i++) {\n\t\t\t\t\tr = this.selectFromTable(table);\n\t\t\t\t\tresult = result.concat(r);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t\n\t\trtable.result = result;\n\t\treturn result;\n\t};\n\t/**\n\t * Get a result from a table/subtable in a RandomTable object\n\t * DANGER: you could theoretically put yourself in an endless loop if the data were poorly planned\n\t * ...but at worst that would just crash the users browser since there's no server processing involved... (???)\n\t * @todo we'll have to fix for this with a node version\n\t * @param {Object} rtable the RandomTable object\n\t * @param {String} table table to roll on\n\t * @returns {Array} array of object results { table: table that was rolled on, result: result string, desc: optional description string }\n\t */\n\tthis.selectFromTable = function (rtable, table) {\n\t\tif (!r_helpers.isObject(rtable)) {\n\t\t\treturn [{ table: 'Error', result: 'No table found to roll on.', desc: '' }];\n\t\t}\n\t\tif (typeof table === 'undefined') {\n\t\t\treturn [{ table: 'Error', result: 'No table found to roll on.', desc: '' }];\n\t\t}\n\t\t// console.log(table);\n\t\tlet o = []; // output for sequence of rolls/selections\n\t\tconst t = rtable.tables[table]; // the table/subtable\n\t\tconst result = this.rollRandom(t); // the random string from the table (either the object property, a string value from an array, or the value property from a selected object)\n\t\tlet r = ''; // the string result from the table\n\t\tlet result_print = true; // are we going to show this result\n\t\t\n\t\tif (r_helpers.isUndefined(t[result])) {\n\t\t\t// table is an array\n\t\t\t// r = _.findWhere(t, { label: result });\n\t\t\tr = t.find((v) => {\n\t\t\t\treturn v.label === result;\n\t\t\t});\n\t\t\tif (r_helpers.isUndefined(r)) {\n\t\t\t\t// it's just an array of strings so we can stop here\n\t\t\t\to.push({ table: table, result: result, desc: '' });\n\t\t\t\treturn o;\n\t\t\t}\n\t\t\tresult_print = (typeof r['print'] === 'undefined') ? true : r['print'];\n\t\t} else {\n\t\t\tr = t[result];\n\t\t\tresult_print = (typeof t[result]['print'] === 'undefined') ? true : t[result]['print'];\n\t\t}\n\t\t// r is now the result object\n\t\t\n\t\t// if print==false we suppress the output from this table (good for top-level tables)\n\t\tif (result_print === true) {\n\t\t\t// add the description if there is one\n\t\t\tconst desc = (r_helpers.isString(r['description'])) ? r['description'] : '';\n\t\t\t// replace any tokens\n\t\t\tconst t_result = this.findToken(result, rtable.key);\n\t\t\to.push({ table: table, result: t_result, desc: desc });\n\t\t}\n\t\t\n\t\t// are there subtables to roll on?\n\t\tconst subtable = r.subtable;\n\t\tlet r2 = ''; // subtable results\n\t\tif (typeof subtable === 'undefined') {\n\t\t\t// no subtables\n\t\t\treturn o;\n\t\t} else if (r_helpers.isString(subtable)) {\n\t\t\t// subtables is a string reference to a table so we run this function again\n\t\t\tr2 = this.selectFromTable(rtable, subtable);\n\t\t\to = o.concat(r2);\n\t\t} else if (Array.isArray(subtable)) {\n\t\t\t// subtables is an array, assume reference to other tables, roll on each in turn\n\t\t\tsubtable.forEach((v) => {\n\t\t\t\tr2 = this.selectFromTable(rtable, v);\n\t\t\t\to = o.concat(r2);\n\t\t\t});\n\t\t} else if (r_helpers.isObject(subtable)) {\n\t\t\t// subtable is object assume embedded table(s)\n\t\t\t// loop over keys\n\t\t\tconst k = Object.keys(subtable);\n\t\t\tk.forEach((kx) => {\n\t\t\t\tlet result = this.rollRandom(subtable[kx]);\n\t\t\t\tlet desc = '';\n\t\t\t\tif (r_helpers.isUndefined(subtable[kx][result])) {\n\t\t\t\t\t// r2 = _.findWhere(subtable[kx], { label: result });\n\t\t\t\t\tr2 = subtable[kx].find((v) => {\n\t\t\t\t\t\treturn v.label === result;\n\t\t\t\t\t});\n\t\t\t\t\tif (r_helpers.isObject(r2)) {\n\t\t\t\t\t\tdesc = (r_helpers.isString(r2.description)) ? r2.description : '';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdesc = (r_helpers.isString(subtable[kx][result]['description'])) ? subtable[kx][result]['description'] : '';\n\t\t\t\t}\n\t\t\t\tresult = this.findToken(result, rtable.key);\n\t\t\t\t\n\t\t\t\to.push({ table: kx, result: result, desc: desc });\n\t\t\t});\n\t\t}\n\t\t\n\t\treturn o;\n\t};\n\t/**\n\t * Perform token replacement.  Only table and roll actions are accepted\n\t * @param {String} token A value passed from findToken containing a token(s) {{SOME OPERATION}} Tokens are {{table:SOMETABLE}} {{table:SOMETABLE:SUBTABLE}} {{table:SOMETABLE*3}} (roll that table 3 times) {{roll:1d6+2}} (etc) (i.e. {{table:colonial_occupations:laborer}} {{table:color}} also generate names with {{name:flemish}} (surname only) {{name:flemish:male}} {{name:dutch:female}}\n\t * @param {String} curtable key of the RandomTable the string is from (needed for \"this\" tokens)\n\t * @returns {String} The value with the token(s) replaced by the operation or else just the token (in case it was a mistake or at least to make the error clearer)\n\t */\n\tthis.convertToken = function (token, curtable) {\n\t\tconst parts = token.replace('{{', '').replace('}}', '').split(':');\n\t\tif (parts.length === 0) { return token; }\n\t\t\n\t\t// look for a token type we can run\n\t\tif (this.token_types[parts[0]]) {\n\t\t\treturn this.token_types[parts[0]](parts, token, curtable);\n\t\t} else {\n\t\t\treturn token;\n\t\t}\n\t};\n\t/**\n\t * Look for tokens to perform replace action in convertToken\n\t * @param {String} string usually a result from a RandomTable\n\t * @param {String} curtable key of the RandomTable the string is from (needed for \"this\" tokens)\n\t * @returns {String} String with tokens replaced (if applicable)\n\t */\n\tthis.findToken = function (string, curtable) {\n\t\tif (r_helpers.isEmpty(string)) { return ''; }\n\t\tif (typeof curtable === 'undefined') { curtable = ''; }\n\t\tconst regexp = new RegExp('({{2}.+?}{2})', 'g');\n\t\tconst newstring = string.replace(regexp, (token) => {\n\t\t\treturn this.convertToken(token, curtable);\n\t\t});\n\t\treturn newstring;\n\t};\n\t/**\n\t * takes a string like '3d6+2', 'd6', '2d6', parses it, and puts it through roll\n\t * @params {String} string a die roll notation\n\t * @returns {Number} the result of the roll\n\t */\n\tthis.roll = function (string) {\n\t\tstring = (typeof string === 'undefined') ? '' : string.trim();\n\t\tconst m = string.match(/^([0-9]*)d([0-9]+)(?:([\\+\\-\\*\\/])([0-9]+))*$/);\n\t\tif (m) {\n\t\t\tif (typeof m[4] === 'undefined') { m[4] = 0; }\n\t\t\tif (m[1] !== '') {\n\t\t\t\treturn parseDiceNotation.call(this, parseInt(m[2], 10), parseInt(m[1], 10), parseInt(m[4], 10), m[3]);\n\t\t\t} else {\n\t\t\t\treturn parseDiceNotation.call(this, parseInt(m[2], 10), '1', parseInt(m[4], 10), m[3]);\n\t\t\t}\n\t\t}\n\t\treturn '';\n\t};\n\t/**\n\t * Since tables are stored outside of this module, this function allows for the setting of a function which will be used to lookup a table by it's key\n\t * @param {Function} lookup a function that takes a table key and returns the table data object\n\t * @return {null} nothing\n\t */\n\tthis.setTableKeyLookup = function (lookup) {\n\t\tthis.getTableByKey = lookup;\n\t};\n\t/**\n\t * Placeholder that should be replaced by a function outside this module\n\t * @param {String} key human readable table identifier\n\t * @return {null} nothing, when replaced this function should return a table object\n\t */\n\tthis.getTableByKey = function (key) {\n\t\treturn null;\n\t};\n\t/**\n\t * Add a token variable\n\t * @param {String} name Name of the token (used as first element\n\t * @param {Function} process Function to return token replacement value function is passed the token_parts (token split by \":\"),  original full_token, current table name\n\t */\n\tthis.registerTokenType = function (name, process) {\n\t\tthis.token_types[name] = process;\n\t};\n\t/**\n\t * Dice roll token.\n\t */\n\tthis.registerTokenType('roll', (token_parts, full_token, curtable) => {\n\t\treturn this.roll(token_parts[1]);\n\t});\n\t/**\n\t * Table token lookup in the form:\n\t * {{table:SOMETABLE}} {{table:SOMETABLE:SUBTABLE}} {{table:SOMETABLE*3}} (roll that table 3 times) {{table:SOMETABLE:SUBTABLE*2}} (roll subtable 2 times)\n\t */\n\tthis.registerTokenType('table', (token_parts, full_token, curtable) => {\n\t\tlet string = '';\n\t\t// console.log(token_parts);\n\t\tif (typeof token_parts[1] === 'undefined') {\n\t\t\treturn full_token;\n\t\t}\n\t\tlet multiplier = 1;\n\t\tif (token_parts[1].indexOf('*') !== -1) {\n\t\t\tconst x = token_parts[1].split('*');\n\t\t\ttoken_parts[1] = x[0];\n\t\t\tmultiplier = x[1];\n\t\t}\n\t\t\n\t\t// what table do we roll on\n\t\tlet t = null;\n\t\tif (token_parts[1] === 'this') {\n\t\t\t// reroll on same table\n\t\t\t// console.log('this..'+curtable);\n\t\t\tt = this.getTableByKey(curtable);\n\t\t\t// console.log(t);\n\t\t} else {\n\t\t\tt = this.getTableByKey(token_parts[1]);\n\t\t\t// console.log(t);\n\t\t}\n\t\tif (t === null || typeof t !== 'object') {\n\t\t\treturn full_token;\n\t\t}\n\t\tif (typeof token_parts[2] !== 'undefined' && token_parts[2].indexOf('*') !== -1) {\n\t\t\tconst x = token_parts[2].split('*');\n\t\t\ttoken_parts[2] = x[0];\n\t\t\tmultiplier = x[1];\n\t\t}\n\t\tconst subtable = (typeof token_parts[2] === 'undefined') ? '' : token_parts[2];\n\n\t\tfor (var i = 1; i <= multiplier; i++) {\n\t\t\tthis.getTableResult(t, subtable);\n\t\t\tstring += t.niceString() + ', ';\n\t\t}\n\t\tstring = string.trim();\n\t\tstring = string.replace(/,$/, '');\n\t\treturn string;\n\t});\n};\n\nmodule.exports = new Randomizer();\n","'use strict';\n\nconst r_helpers = require('./r_helpers.js');\n\n/**\n * RandomTable: Model for tables used by Randomizer\n * @param {Object} config the tables non-default attributes\n */\nconst RandomTable = function (config) {\n\t/**\n\t * The primary attributes of this table\n\t * @property {String} id id for the table, primary key for database if used\n\t * @property {String} key identifier for the table\n\t * @property {String} [title] title of the table\n\t * @property {String} [author] author of the table\n\t * @property {String} [description] description of the table\n\t * @property {String} [source] source of the table\n\t * @property {Array} [tags] subject tags\n\t * @property {String|Array} [sequence] tables to roll on. if array it can be an array of strings (table names) or objects (two properties table: the table to roll on and times: the number of times to roll)\n\t * @property {Array} [table] default table. array of strings or objects. removed after initialization.\n\t * @property {Object} [tables] a property for each subtables. if table property is not set then the first propery of this Object is used to start rolling\n\t * @property {Array} [macro] for tables that are only used to aggregate result from other tables, this array consists of table keys to be rolled on in order\n\t * @property {Object} [print] objects to describe what parts of a (sub)table should be displayed in the results\n\t * @property {Object} [print.default] how to display the default table's results\n\t * @property {Object} [print.default.hide_table] set to 1 will not show the table name\n\t * @property {Object} [print.default.hide_result] set to 1 will not show the result on that (sub)table\n\t * @property {Object} [print.default.hide_desc] set to 1 will not show any description for a result on that (sub)table\n\t * @property {Array} [result] current result array of objects\n\t */\n\tthis.id = 0;\n\tthis.key = '';\n\tthis.title = '';\n\tthis.author = '';\n\tthis.description = '';\n\tthis.source = '';\n\tthis.tags = [];\n\tthis.sequence = ''; // where to start rolling and if other tables should always be rolled on\n\tthis.tables = {};\n\tthis.macro = [];\n\tthis.result = [];\n\t/**\n\t * Run on first construction\n\t * @param {Object} config data passed from the constructor\n\t */\n\tconst initialize = function (config) {\n\t\tfor (const prop in config) {\n\t\t\tif (config.hasOwnProperty(prop)) {\n\t\t\t\tthis[prop] = config[prop];\n\t\t\t}\n\t\t}\n\t\t// make sure this.tables.default is set instead of this.table\n\t\t// maybe we dont need this\n\t\tif (!r_helpers.isEmpty(this.table)) {\n\t\t\tconst tables = this.tables;\n\t\t\ttables.default = this.table;\n\t\t\tthis.tables = tables;\n\t\t\tdelete this.table;\n\t\t}\n\t\tif (this.key === '') {\n\t\t\tthis.key = this.id;\n\t\t}\n\t};\n\t/**\n\t * validate fields before saving\n\t * @param {Object} properties new attributes to save\n\t * @returns {Object} error information\n\t */\n\tthis.validate = function (properties) {\n\t\t// console.log(attributes);\n\t\tconst error = { fields: [], general: '' };\n\t\t\n\t\tif (properties.title === '') {\n\t\t\terror.fields.push({ field: 'title', message: 'Title cannot be blank' });\n\t\t\terror.general += 'Title cannot be blank. ';\n\t\t}\n\t\t\n\t\tif (r_helpers.isEmpty(properties.tables) && r_helpers.isEmpty(properties.macro)) {\n\t\t\terror.fields.push({ field: 'tables', message: 'Both Tables and Macro cannot be empty' });\n\t\t\terror.general += 'Both Tables and Macro cannot be empty. ';\n\t\t}\n\t\t\n\t\tif (!r_helpers.isEmpty(error.fields) || !r_helpers.isEmpty(error.general)) {\n\t\t\treturn error;\n\t\t}\n\t\treturn true;\n\t};\n\t/**\n\t * Show the results as a string\n\t * @todo make this nicer/clearer #23\n\t * Alternate: write a template to use in the views?\n\t * @param {Boolean} [simple=false] if true only output the first result label\n\t * @returns {String} the results\n\t */\n\tthis.niceString = function (simple) {\n\t\tif (typeof simple === 'undefined') {\n\t\t\tsimple = false;\n\t\t}\n\t\tconst r = this.result; // array\n\t\tif (r_helpers.isString(r) || !Array.isArray(r) || r.length === 0) { return ''; }\n\t\t\n\t\tif (simple) { return r[0]['result']; } // @todo maybe use shift() instead, if editing this array won't be a problem. (else we could clone it...\n\t\t\n\t\tlet o = '';\n\t\tconst print_opt = (this.print) ? this.print : {};\n\t\tr.forEach((v) => {\n\t\t\tif (print_opt[v.table]) {\n\t\t\t\tif (!print_opt[v.table].hide_table || print_opt[v.table].hide_table === 0) {\n\t\t\t\t\to += `${r_helpers.capitalize(v.table)}: `;\n\t\t\t\t}\n\t\t\t\tif (!print_opt[v.table].hide_result || print_opt[v.table].hide_result === 0) {\n\t\t\t\t\to += `${r_helpers.capitalize(v.result)}\\n`;\n\t\t\t\t}\n\t\t\t\tif (!print_opt[v.table].hide_desc || print_opt[v.table].hide_desc === 0) {\n\t\t\t\t\tif (v.desc !== '') { o += `${v.desc}\\n`; }\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (v.table === 'default') {\n\t\t\t\t\to += `${r_helpers.capitalize(v.result)}\\n`;\n\t\t\t\t} else {\n\t\t\t\t\to += `${r_helpers.capitalize(v.table)}: ${r_helpers.capitalize(v.result)}\\n`;\n\t\t\t\t}\n\t\t\t\tif (v.desc !== '') { o += `${v.desc}\\n`; }\n\t\t\t}\n\t\t});\n\t\to = o.trim(); // trim off final linebreak\n\t\treturn o;\n\t};\n\t/**\n\t * outputs the json data for the table (import/export)\n\t * @param {Boolean} [editmode=false] if false empty properties will be stripped out\n\t * @returns {Object} table attributes\n\t */\n\tthis.outputObject = function (editmode) {\n\t\tif (typeof editmode === 'undefined') { editmode = false; }\n\t\t// clone the data, this will strip out any functions too.\n\t\tconst att = JSON.parse(JSON.stringify(this));\n\t\tconst props = Object.keys(att);\n\t\tprops.forEach((k) => {\n\t\t\tif (!editmode && r_helpers.isEmpty(att[k])) {\n\t\t\t\tdelete att[k];\n\t\t\t}\n\t\t});\n\t\t// don't include results\n\t\tif (att.result && editmode) {\n\t\t\tatt.result = [];\n\t\t} else if (att.result) {\n\t\t\tdelete att.result;\n\t\t}\n\t\tdelete att.id;\n\t\treturn att;\n\t};\n\t/**\n\t * outputs the json data for the table (import/export)\n\t * @param {Boolean} [editmode=false] if false empty properties will be stripped out\n\t * @param {Boolean} [compress=false] if true JSON will not have indentation, etc.\n\t * @returns {String} table properties in JSON\n\t */\n\tthis.outputCode = function (editmode, compress) {\n\t\tif (typeof editmode === 'undefined') { editmode = false; }\n\t\tif (typeof compress === 'undefined') { compress = false; }\n\t\t\n\t\tconst obj = this.outputObject(editmode);\n\t\t\n\t\tif (compress) {\n\t\t\treturn JSON.stringify(obj);\n\t\t}\n\t\treturn JSON.stringify(obj, null, 2);\n\t};\n\t/**\n\t * Get an object result in case we only have the label and need other data from it\n\t * @param {String} label The item we are looking for\n\t * @param {String} [table=default] the table to search\n\t * @returns {Object} the object associated with the label or an empty one\n\t */\n\tthis.findObject = function (label, table) {\n\t\tif (typeof table === 'undefined' || table === '') {\n\t\t\ttable = 'default';\n\t\t}\n\t\tconst t = this.tables[table];\n\t\tif (t[label]) {\n\t\t\treturn t[label];\n\t\t}\n\t\tif (Array.isArray(t)) {\n\t\t\tconst obj = t.find((v) => {\n\t\t\t\treturn v.label === label;\n\t\t\t});\n\t\t\treturn (typeof obj !== 'undefined') ? obj : {};\n\t\t}\n\t\treturn {};\n\t};\n\t/**\n\t  * find the result element for a specific table/subtable\n\t  * only works if we have already generated a result\n\t  * @param {String} table The table to look for\n\t  * @returns {Object} result element for specified table (or empty)\n\t  */\n\tthis.findResultElem = function (table) {\n\t\tif (typeof table === 'undefined' || table === '') {\n\t\t\ttable = 'default';\n\t\t}\n\t\tconst obj = this.result.find((v) => {\n\t\t\treturn v.table === table;\n\t\t});\n\t\treturn (typeof obj !== 'undefined') ? obj : {};\n\t};\n\t\n\t/**\n\t * Initialize the table, set the data, normalize, etc.\n\t */\n\tinitialize.call(this, config);\n};\n\nmodule.exports = RandomTable;\n","'use strict';\n\nconst r_helpers = require('./r_helpers');\n\n/**\n * Take some data and normalize it into a config object for RandomTable\n * Module exports a constructor function\n */\nconst TableNormalizer = function (data) {\n\tthis.orig_data = (typeof data !== 'undefined') ? data : ''; // save this for later if necessary\n\tthis.normalized_data = {}; // normalized config object for RandomTable\n\tthis.data_type = '';\n\t\n\t/**\n\t * Set the data\n\t * @param {String|Object|Array} data the data to normalize\n\t */\n\tthis.setData = function (data) {\n\t\tthis.orig_data = data;\n\t};\n\t/**\n\t * Decide what type of data it is so we can treat it appropriately.\n\t * @return {String} data_type\n\t */\n\tthis.checkType = function () {\n\t\tconst data = this.orig_data;\n\t\tif (r_helpers.isEmpty(data)) {\n\t\t\tthis.data_type = '';\n\t\t} else if (r_helpers.isString(data)) {\n\t\t\t// html should start with a tag.... right?\n\t\t\t// @todo I'm sure there's a better way\n\t\t\ttry {\n\t\t\t\tJSON.parse(data);\n\t\t\t\tthis.data_type = 'json';\n\t\t\t\treturn this.data_type;\n\t\t\t} catch (e) {\n\t\t\t\t// not json\n\t\t\t}\n\t\t\tif (data.substring(0, 1) === '<') {\n\t\t\t\tthis.data_type = 'html';\n\t\t\t\treturn this.data_type;\n\t\t\t}\n\t\t\tthis.data_type = 'text';\n\t\t} else if (r_helpers.isObject(data)) {\n\t\t\tthis.data_type = 'object';\n\t\t}\n\t\treturn this.data_type;\n\t};\n\t/**\n\t * Try to parse HTML into table object data\n\t * @return {Array} table options\n\t */\n\tthis.parseHtml = function () {\n\t\tlet html = this.orig_data;\n\t\t// strip linebreaks cause we'll be making new ones based on the tags\n\t\thtml = html.replace(/[\\n\\r]+/g, '');\n\t\t// add line breaks for specific end tags li tr p br\n\t\t// @todo really <tr> leaves you with some weird data.\n\t\thtml = html.replace(/<\\/(p|tr|li|div)>|<\\/?br\\/?>/g, '\\n').replace(/\\t/g, '');\n\t\t\n\t\thtml = html.replace(/<\\/?[^>]+>/g, '').replace(/[\\n\\r]+$/g, '');\n\t\t// console.log(html);\n\t\tconst text = html.split(/[\\n\\r]+/g);\n\t\t// console.log(text);\n\t\t\n\t\tlet ct = 0;\n\t\t\n\t\ttext.forEach((v, k, l) => {\n\t\t\tv = v.trim(); // trim spaces from ends\n\t\t\t// parse out the pre-post ## data (if it's there)\n\t\t\tconst parse = v.match(/^(?:(?:[0-9]+\\-)?([0-9]+)(##)?(?:\\.\\s*|:\\s*|,\\s*|\\t+|\\s*))?(.+?)(?:##(.+))?$/);\n\t\t\t\n\t\t\tif (parse) {\n\t\t\t\tl[k] = { label: parse[3].trim() };\n\t\t\t\t\n\t\t\t\tif (typeof parse[1] !== 'undefined') {\n\t\t\t\t\tlet weight = 1;\n\t\t\t\t\tif (typeof parse[2] === 'undefined') {\n\t\t\t\t\t\tweight = parseFloat(parse[1]) - ct;\n\t\t\t\t\t\tif (weight < 1) { weight = 1; }\n\t\t\t\t\t\tct = ct + weight;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tweight = parseFloat(parse[1]);\n\t\t\t\t\t}\n\t\t\t\t\tif (weight > 1) {\n\t\t\t\t\t\tl[k].weight = weight;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tct++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (typeof parse[4] !== 'undefined') {\n\t\t\t\t\tl[k].subtable = parse[4].trim();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdelete l[k];\n\t\t\t}\n\t\t});\n\t\treturn text;\n\t};\n\t/**\n\t * Try to parse text into table data\n\t * @returns {Array} parsed table data\n\t */\n\tthis.parseText = function () {\n\t\tlet text = this.orig_data;\n\t\t// split it into an array of lines\n\t\ttext = text.split(/[\\n\\r]+/g);\n\n\t\tlet ct = 0; // the cumulative 'die' count we'll use to calculate the weight\n\t\ttext.forEach((v, k, l) => {\n\t\t\tv = v.trim();\n\t\t\t\n\t\t\t// parse numbers off front and subtables off back\n\t\t\tconst parse = v.match(/^(?:(?:[0-9]+\\-)?([0-9]+)(##)?(?:\\.\\s*|:\\s*|,\\s*|\\t+|\\s*))?(.+?)(?:##(.+))?$/);\n\t\t\t// console.log(parse);\n\t\t\tif (parse) {\n\t\t\t\t// console.log(parse);\n\t\t\t\tlet label = parse[3].trim();\n\t\t\t\tlabel = label.replace(/^[-*]\\s?/, '');\n\t\t\t\tl[k] = { label: label };\n\t\t\t\t\n\t\t\t\tif (typeof parse[1] !== 'undefined') {\n\t\t\t\t\tlet weight = 1;\n\t\t\t\t\tif (typeof parse[2] === 'undefined') {\n\t\t\t\t\t\tweight = parseFloat(parse[1]) - ct;\n\t\t\t\t\t\t// console.log(weight);\n\t\t\t\t\t\tif (weight < 1) { weight = 1; }\n\t\t\t\t\t\tct = ct + weight;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tweight = parseFloat(parse[1]);\n\t\t\t\t\t}\n\t\t\t\t\tif (weight > 1) {\n\t\t\t\t\t\tl[k].weight = weight;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tct++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (typeof parse[4] !== 'undefined') {\n\t\t\t\t\tl[k].subtable = parse[4].trim();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdelete l[k];\n\t\t\t}\n\t\t});\n\t\treturn text;\n\t};\n\t/**\n\t * Parse markdown...?\n\t * @todo\n\t */\n\tthis.parseMarkdown = function () {\n\t\t// deal with headers\n\t\t// deal with lists and sublists.\n\t\t\n\t};\n\t/**\n\t * Process the data and try to do something\n\t */\n\tthis.normalizeData = function () {\n\t\tconst type = this.checkType();\n\t\tif (type === '') {\n\t\t\treturn false;\n\t\t}\n\t\tlet parse_data = null;\n\t\tswitch (type) {\n\t\t\tcase 'html':\n\t\t\t\tthis.normalized_data = this.parseHtml();\n\t\t\t\tbreak;\n\t\t\tcase 'text':\n\t\t\t\tthis.normalized_data = this.parseText();\n\t\t\t\tbreak;\n\t\t\tcase 'json':\n\t\t\t\tparse_data = JSON.parse(this.orig_data);\n\t\t\t\tthis.normalized_data = parse_data;\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\t// ?\n\t\treturn this.normalized_data;\n\t};\n};\n\nmodule.exports = TableNormalizer;\n","'use strict';\n\nconst r_helpers = require('./r_helpers.js');\n\n/**\n * Name generator...\n * @param {Object} randomizer an instance of randomizer module\n * @param {Object} namedata a lot of names divided by type. see /samples/names.json for formatting\n */\nmodule.exports = function random_name (randomizer, namedata) {\n\t\n\tif (typeof namedata === 'undefined') {\n\t\tconst namedata = { options: {} };\n\t}\n\t\n\t/**\n\t * Generate a bunch of names, half male, half female\n\t * @param {Number} [number=10] number of names in the list (half will be male, half will be female)\n\t * @param {String} [name_type] type of name or else it will randomly select\n\t * @param {Bool} [create=false] new names or just pick from list\n\t * @return {Object} arrays of names inside male/female property\n\t */\n\tconst generateList = function (number, name_type, create) {\n\t\tconst names = { male: [], female: [] };\n\t\tif (typeof create === 'undefined') { create = false; }\n\t\tif (typeof number === 'undefined') { number = 10; }\n\t\tif (typeof name_type === 'undefined' || name_type === '') {\n\t\t\tname_type = 'random';\n\t\t}\n\t\t\n\t\tfor (let i = 1; i <= number; i++) {\n\t\t\tconst gender = (i <= Math.ceil(number / 2)) ? 'male' : 'female';\n\t\t\tif (create && name_type !== 'holmesian' && name_type !== 'demonic') {\n\t\t\t\tnames[gender].push(createName(name_type, gender, true));\n\t\t\t} else {\n\t\t\t\tnames[gender].push(selectName(name_type, gender));\n\t\t\t}\n\t\t}\n\t\treturn names;\n\t};\n\t/**\n\t * Select a name from one of the lists\n\t * @param {String} name_type What name list/process to use else random\n\t * @param {String} gender male, female, random, ''\n\t * @param {String} style first=first name only, else full name\n\t * @returns {String} a name\n\t */\n\tconst selectName = function (name_type, gender, style) {\n\t\tlet name = '';\n\t\t\n\t\tif (typeof name_type === 'undefined' || name_type === '' || name_type === 'random') {\n\t\t\t// randomize a type...\n\t\t\tname_type = randomizer.rollRandom(Object.keys(namedata.options));\n\t\t}\n\t\tif (typeof gender === 'undefined' || gender === 'random') {\n\t\t\t// randomize a gender...\n\t\t\tgender = randomizer.rollRandom(['male', 'female']);\n\t\t}\n\t\tif (typeof style === 'undefined' || style !== 'first') {\n\t\t\tstyle = '';\n\t\t}\n\t\t\n\t\tswitch (name_type) {\n\t\t\tcase 'holmesian':\n\t\t\t\tname = holmesname();\n\t\t\t\tbreak;\n\t\t\tcase 'demonic':\n\t\t\t\tname = demonname();\n\t\t\t\tbreak;\n\t\t\tcase 'cornish':\n\t\t\tcase 'flemish':\n\t\t\tcase 'dutch':\n\t\t\tcase 'turkish':\n\t\t\tdefault:\n\t\t\t\tname = randomizer.rollRandom(namedata[name_type][gender]);\n\t\t\t\tif (typeof namedata[name_type]['surname'] !== 'undefined' && style !== 'first') {\n\t\t\t\t\tname += ' ' + randomizer.rollRandom(namedata[name_type]['surname']);\n\t\t\t\t}\n\t\t\t\tname = randomizer.findToken(name).trim();\n\t\t\t\tbreak;\n\t\t}\n\t\treturn capitalizeName(name);\n\t};\n\t/**\n\t * Select a sur/last name only from one of the lists\n\t * @param {String} name_type what list/process to use, else random\n\t * @returns {String} a name\n\t */\n\tconst selectSurname = function (name_type) {\n\t\tlet name = '';\n\t\tif (typeof name_type === 'undefined' || name_type === '' || name_type === 'random') {\n\t\t\t// randomize a type...\n\t\t\tname_type = randomizer.rollRandom(Object.keys(namedata.options));\n\t\t}\n\t\tswitch (name_type) {\n\t\t\tcase 'holmesian':\n\t\t\t\tname = holmesname();\n\t\t\t\tbreak;\n\t\t\tcase 'cornish':\n\t\t\tcase 'flemish':\n\t\t\tcase 'dutch':\n\t\t\tcase 'turkish':\n\t\t\tdefault:\n\t\t\t\tname = randomizer.rollRandom(namedata[name_type]['surname']);\n\t\t\t\tname = randomizer.findToken(name);\n\t\t\t\tbreak;\n\t\t}\n\t\treturn capitalizeName(name);\n\t};\n\t/**\n\t * Create a name using Markov chains\n\t * @param {String} [name_type=random] what list/process to use\n\t * @param {String} [gender=random] male or female or both\n\t * @param {String} style first=first name only, else full name\n\t * @returns {String} a name\n\t */\n\tconst createName = function (name_type, gender, style) {\n\t\tif (typeof name_type === 'undefined' || name_type === '' || name_type === 'random') {\n\t\t\t// randomize a type...\n\t\t\tname_type = randomizer.rollRandom(Object.keys(namedata.options));\n\t\t}\n\t\tif (typeof style === 'undefined') { style = ''; }\n\t\tif (!namedata[name_type]) { return ''; }\n\t\tif (typeof gender === 'undefined' || (gender !== 'male' && gender !== 'female')) { gender = ''; }\n\t\t\n\t\tconst mkey = `${name_type}_${gender}`;\n\t\tlet lastname = '';\n\t\tlet thename = '';\n\t\t\n\t\tif (!markov.memory) {\n\t\t\tmarkov = new MarkovGenerator({ order: 3 });\n\t\t}\n\t\t\n\t\tif (!markov.memory[mkey]) {\n\t\t\t// console.log('learn '+mkey);\n\t\t\tlet namelist = [];\n\t\t\tif (gender === '') {\n\t\t\t\tnamelist = namedata[name_type]['male'];\n\t\t\t\tnamelist = namelist.concat(namedata[name_type]['female']);\n\t\t\t} else {\n\t\t\t\tnamelist = namedata[name_type][gender];\n\t\t\t}\n\t\t\tnamelist.forEach((v) => {\n\t\t\t\tmarkov.learn(mkey, v);\n\t\t\t});\n\t\t}\n\t\t\n\t\tif (style !== 'first' && !r_helpers.isEmpty(namedata[name_type]['surname'])) {\n\t\t\tconst skey = name_type + '_last';\n\t\t\tif (!markov.memory[skey]) {\n\t\t\t\t// console.log('learn surname '+skey);\n\t\t\t\tconst namelist = namedata[name_type]['surname'];\n\t\t\t\tnamelist.forEach((v) => {\n\t\t\t\t\tmarkov.learn(skey, v);\n\t\t\t\t});\n\t\t\t}\n\t\t\tlastname = markov.generate(skey);\n\t\t}\n\t\t\n\t\tthename = `${markov.generate(mkey)} ${lastname}`;\n\t\treturn capitalizeName(thename.trim());\n\t};\n\t/**\n\t * Capitalize names, account for multiword lastnames like \"Van Hausen\"\n\t * @param {String} name a name\n\t * @return {String} name capitalized\n\t */\n\tconst capitalizeName = function (name) {\n\t\tconst leave_lower = ['of', 'the', 'from', 'de', 'le', 'la'];\n\t\t// need to find spaces in name and capitalize letter after space\n\t\tconst parts = name.split(' ');\n\t\tconst upper_parts = parts.map((w) => {\n\t\t\treturn (leave_lower.indexOf(w) >= 0) ? w : `${r_helpers.capitalize(w)}`;\n\t\t});\n\t\treturn upper_parts.join(' ');\n\t};\n\t/**\n\t * Generate a Holmes name\n\t * @returns {String} name\n\t */\n\tconst holmesname = function () {\n\t\tlet name = '';\n\t\tconst scount = randomizer.getWeightedRandom(namedata.holmesian_scount.values, namedata.holmesian_scount.weights);\n\t\n\t\tfor (let i = 1; i <= scount; i++) {\n\t\t\tname += randomizer.rollRandom(namedata.holmesian_syllables); // array\n\t\t\tif (i < scount) {\n\t\t\t\tname += randomizer.getWeightedRandom(['', ' ', '-'], [3, 2, 2]);\n\t\t\t}\n\t\t}\n\t\tname = name.toLowerCase() + ' ' + randomizer.rollRandom(namedata.holmesian_title);\n\t\t\n\t\tname = randomizer.findToken(name);\n\t\t\n\t\tname = name.replace(/[\\s\\-]([a-z]{1})/g, (match) => {\n\t\t\treturn match.toUpperCase();\n\t\t});\n\t\treturn name;\n\t};\n\t/**\n\t * Demonic name\n\t * Taken from Jeff Rients, based on Goetia, as implemented here: http://www.random-generator.com/index.php?title=Goetic_Demon_Names\n\t * @return {String} a name\n\t */\n\tconst demonname = function () {\n\t\tlet name = '';\n\t\tconst format = randomizer.getWeightedRandom([ ['first', 'last'], ['first', 'inner', 'last'], ['first', 'inner', 'inner', 'last'], ['first', 'inner', 'inner', 'inner', 'last'] ], [55, 35, 7, 3]);\n\t\tfor (let i = 0; i < format.length; i++) {\n\t\t\tname += randomizer.rollRandom(namedata.demonic[format[i]]);\n\t\t}\n\t\treturn name;\n\t};\n\t/**\n\t * Add some name data\n\t * Note: you can overwrite existing name_types if you want\n\t * @param {String} name_type the shortname for the type\n\t * @param {Object} data names\n\t * @param {Array} data.male male names\n\t * @param {Array} data.female female names\n\t * @param {Array} data.surnames surnames\n\t * @param {String} [label] descriptive name of type (defaults to just the name_type)\n\t * @return {Boolean} success or failure\n\t */\n\tconst registerNameType = function (name_type, data, label) {\n\t\tif (typeof name_type === 'undefined' || label === '') {\n\t\t\treturn false;\n\t\t}\n\t\tif (typeof label === 'undefined' || label === '') {\n\t\t\tlabel = name_type;\n\t\t}\n\t\tif (!data.male && !data.female && !data.surname) {\n\t\t\treturn false;\n\t\t}\n\t\tnamedata[name_type] = data;\n\t\tnamedata.options[name_type] = label;\n\t\treturn true;\n\t};\n\t/**\n\t * Register the name token with the randomizer\n\t */\n\trandomizer.registerTokenType('name', (token_parts, full_token, curtable) => {\n\t\tlet string = '';\n\t\t// const n = this;\n\t\tif (typeof token_parts[1] === 'undefined' || token_parts[1] === '' || token_parts[1] === 'random') {\n\t\t\ttoken_parts[1] = '';\n\t\t}\n\t\tif (typeof token_parts[3] === 'undefined' || token_parts[3] !== 'first') {\n\t\t\ttoken_parts[3] = '';\n\t\t}\n\t\tif (typeof token_parts[2] === 'undefined' || token_parts[2] === '') {\n\t\t\ttoken_parts[2] = 'random';\n\t\t}\n\t\tstring = createName(token_parts[1], token_parts[2], token_parts[3]);\n\t\treturn string;\n\t});\n\n\t\n\t/**\n\t * Adapted from http://blog.javascriptroom.com/2013/01/21/markov-chains/\n\t */\n\tconst MarkovGenerator = function (config) {\n\t\tif (typeof config === 'undefined') { config = {}; }\n\t\t/**\n\t\t * the \"memory\" where the language parts go\n\t\t */\n\t\tthis.memory = {};\n\t\t/**\n\t\t * If you want to delimit the generated parts\n\t\t */\n\t\tthis.separator = (config.separator) ? config.separator : '';\n\t\t/**\n\t\t * How many... something... to something.... oh it's been too long I don't remember how this works...\n\t\t */\n\t\tthis.order = (config.order) ? config.order : 2;\n\t\t/**\n\t\t * Feed text to memory\n\t\t * @param {String} key key for the chain (so we can store multiple memories)\n\t\t * @param {String} txt word or phrase\n\t\t * @return {null} null\n\t\t */\n\t\tthis.learn = function (key, txt) {\n\t\t\tconst mem = (this.memory[key]) ? this.memory[key] : {};\n\t\t\t// split up text then add the calculated parts to the memory for this ket\n\t\t\tthis.breakText(txt, (key, value) => {\n\t\t\t\t// console.log(key);\n\t\t\t\tif (!mem[key]) {\n\t\t\t\t\tmem[key] = [];\n\t\t\t\t}\n\t\t\t\tmem[key].push(value);\n\t\t\t\treturn mem;\n\t\t\t});\n\t\t\tthis.memory[key] = mem;\n\t\t};\n\t\t/**\n\t\t * Return a generated response\n\t\t * @param {String} key key for the chain (so we can store multiples\n\t\t * @param {Array} seed letters to start the response (?)\n\t\t */\n\t\tthis.generate = function (key, seed) {\n\t\t\tif (!seed) {\n\t\t\t\tseed = this.genInitial();\n\t\t\t}\n\t\t\tthis.cur_key = key;\n\t\t\treturn seed.concat(this.step(seed, [])).join(this.separator);\n\t\t};\n\t\t/**\n\t\t * iterate through, calls self\n\t\t * @param {Array} state array of most recent x(x=order) elements in chain\n\t\t * @param {Array} ret the chain\n\t\t * @return {Array}\n\t\t */\n\t\tthis.step = function (state, ret) {\n\t\t\tconst nextAvailable = this.memory[this.cur_key][state] || [''];\n\t\t\tconst next = this.getRandomValue(nextAvailable);\n\t\t\t// we don't have anywhere to go\n\t\t\tif (!next) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tret.push(next);\n\t\t\tvar nextState = state.slice(1);\n\t\t\tnextState.push(next);\n\t\t\treturn this.step(nextState, ret);\n\t\t};\n\t\t/**\n\t\t * Chunk the word or phrase\n\t\t * @param {String} txt the text to chunk\n\t\t * @param {Function} cb callback function\n\t\t * @return {null} null\n\t\t */\n\t\tthis.breakText = function (txt, cb) {\n\t\t\tconst parts = txt.split(this.separator);\n\t\t\tconst prev = this.genInitial();\n\t \n\t\t\tparts.forEach((v) => {\n\t\t\t\tv = v.toLowerCase();\n\t\t\t\tcb(prev, v);\n\t\t\t\tprev.shift();\n\t\t\t\tprev.push(v);\n\t\t\t});\n\t\t\tcb(prev, '');\n\t\t};\n\t\t/**\n\t\t * Generate a starting array for the chain based on the order number\n\t\t * @return {Array} just an empty array of length=order\n\t\t */\n\t\tthis.genInitial = function () {\n\t\t\tconst ret = [];\n\t\t\tfor (\n\t\t\t\tlet i = 0;\n\t\t\t\ti < this.order;\n\t\t\t\tret.push(''),\n\t\t\t\ti++\n\t\t\t);\n\t\t\treturn ret;\n\t\t};\n\t\t/**\n\t\t * Get a random array element\n\t\t * @param {Array} arr an array\n\t\t * @return {String|Object}\trandom value\n\t\t */\n\t\tthis.getRandomValue = function (arr) {\n\t\t\treturn arr[Math.floor(Math.random() * arr.length)];\n\t\t};\n\t};\n\t\n\t/**\n\t * Stores the Markov object\n\t */\n\tlet markov = new MarkovGenerator({ order: 3 });;\n\t\n\t\n\treturn {\n\t\tgenerateList: generateList,\n\t\tselectName: selectName,\n\t\tselectSurname: selectSurname,\n\t\tcreateName: createName,\n\t\tcapitalizeName: capitalizeName,\n\t\tholmesname: holmesname,\n\t\tdemonname: demonname,\n\t\tregisterNameType: registerNameType,\n\t\tnamedata: namedata\n\t};\n};\n","'use strict';\n\n/**\n * Is it empty (stolen from Underscore)\n * @param {Object|String|?} obj some type of things\n * @return {Boolean} is it empty?\n */\nconst isEmpty = function (obj) {\n\tif (obj === null || obj === void 0) {\n\t\treturn true;\n\t}\n\tif (Array.isArray(obj) || isString(obj)) {\n\t\treturn obj.length === 0;\n\t}\n\treturn Object.keys(obj).length === 0;\n};\n/**\n * Is it a String (stolen from Underscore)\n * @param {Object|String|?} obj some type of things\n * @return {Boolean} is it an string?\n */\nconst isString = function (obj) {\n\treturn toString.call(obj) === '[object String]';\n};\n/**\n * Is it an Object (stolen from Underscore)\n * @param {Object|String|?} obj some type of things\n * @return {Boolean} is it an object?\n */\nconst isObject = function (obj) {\n\tvar type = typeof obj;\n\treturn type === 'function' || type === 'object' && !!obj;\n};\n/**\n * Is a given variable undefined?\n * @param {Object|String|?} obj object to test\n * @return {Boolean} is it undefined\n */\nconst isUndefined = function (obj) {\n\treturn obj === void 0;\n};\n/**\n * Capitalize a string\n * @param {String} string a string\n * @return {String} string with first letter capitalized\n */\nconst capitalize = function (string) {\n\treturn isEmpty(string) ? string : string.charAt(0).toUpperCase() + string.slice(1);\n};\n\nmodule.exports = {\n\tisEmpty: isEmpty,\n\tisString: isString,\n\tisObject: isObject,\n\tisUndefined: isUndefined,\n\tcapitalize: capitalize\n};\n","'use strict';\n\n/**\n * npc_gen: pass in the randomizer so we can return an object that can use the shared randomizer instance\n * @return {Object} npc functions\n */\nmodule.exports = function npc_gen (randomizer) {\n\t/**\n\t * Object to store NPC constructors.\n\t * each constructor (except the base one) is based on a schema\n\t */\n\tconst NPC = {};\n\t/**\n\t * The base prototype for NPC constructors. From this schemas are used to make differing constructions\n\t */\n\tNPC.Base = function () { };\n\t/**\n\t * Just a unique identifier that can be used for storage/retrieval\n\t */\n\tNPC.Base.prototype.id = 0;\n\t/**\n\t * Name of the schema used for the NPC\n\t */\n\tNPC.Base.prototype.schema = '';\n\t/**\n\t * The NPC's fields as set by the schema\n\t */\n\tNPC.Base.prototype.fields = [];\n\t/**\n\t * Schema assigned helper functions\n\t */\n\tNPC.Base.prototype.helpers = {};\n\t/**\n\t * set defaults on the fields\n\t * usually this would involve calling random tables\n\t */\n\tNPC.Base.prototype.initialize = function () {\n\t\tconst schema_fields = Schemas[this.schema].fields;\n\t\tconst fields = Object.keys(this.fields);\n\t\tfields.forEach((f) => {\n\t\t\tconst sch = schema_fields.find((v) => { return v.key === f; });\n\t\t\tif (sch) {\n\t\t\t\tif (sch.default) {\n\t\t\t\t\tthis.fields[f] = sch.default;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (sch.source && sch.source !== '') {\n\t\t\t\t\t// parse source into something randomizer can use...\n\t\t\t\t\tlet src_temp;\n\t\t\t\t\tif (sch.type === 'function') {\n\t\t\t\t\t\tconst func = new Function(sch.source);\n\t\t\t\t\t\tsrc_temp = func.call(this);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsrc_temp = sch.source;\n\t\t\t\t\t}\n\t\t\t\t\t// console.log(src_temp);\n\t\t\t\t\tif (sch.type === 'array') {\n\t\t\t\t\t\tconst ct = (sch.count) ? sch.count : 1; // ???\n\t\t\t\t\t\tfor (let i = 0; i < ct; i++) {\n\t\t\t\t\t\t\tthis.fields[f].push(randomizer.convertToken(src_temp));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.fields[f] = randomizer.convertToken(src_temp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Take an empty object and set the fields\n\t * @todo should we account for id and schema too?\n\t * @param {Object} fields data for the fields\n\t */\n\tNPC.Base.prototype.set = function (fields) {\n\t\tif (typeof fields !== 'object') { return; }\n\t\tconst props = Object.keys(fields);\n\t\tprops.forEach((p) => {\n\t\t\tif (this.fields[p]) {\n\t\t\t\tthis.fields[p] = fields[p];\n\t\t\t}\n\t\t});\n\t};\n\t\n\t/**\n\t * Object store for registered schemas\n\t */\n\tconst Schemas = {};\n\t\n\t/**\n\t * function to make a new NPC constructor\n\t * constructor is added to NPC[schema.key]\n\t * @param {Object} schema NPC schema object to base on the constructor\n\t * @return {null}\n\t */\n\tconst registerSchema = function (schema) {\n\t\tif (!schema.key || schema.key === 'base' || !Array.isArray(schema.fields)) {\n\t\t\treturn null;\n\t\t\t// throw exception?\n\t\t}\n\t\t// store it for later reference\n\t\tSchemas[schema.key] = schema;\n\t\t// add this schema to the NPC object so we can use it as a constructor\n\t\t// this could overwrite is that ok?\n\t\tconst Base = NPC[schema.key] = function () {\n\t\t\t// in case we add something to NPC constructor that we need to call?\n\t\t\t// NPC.Base.call(this);\n\t\t};\n\t\tBase.prototype = new NPC.Base();\n\t\tBase.prototype.constructor = Base;\n\t\tBase.prototype.schema = schema.key;\n\t\tBase.prototype.fields = [];\n\t\tBase.prototype.helpers = {};\n\t\t\n\t\t// initialize schema properties...\n\t\tschema.fields.forEach((f) => {\n\t\t\tlet default_ = null;\n\t\t\tswitch (f.type) {\n\t\t\t\tcase 'string':\n\t\t\t\tcase 'text':\n\t\t\t\t\tdefault_ = '';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'array':\n\t\t\t\t\tdefault_ = [];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'number':\n\t\t\t\tcase 'modifier':\n\t\t\t\t\tdefault_ = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase undefined:\n\t\t\t\t\t// ?\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tBase.prototype.fields[f.key] = default_;\n\t\t});\n\t\t\n\t\tif (!schema.helpers || typeof schema.helpers !== 'object') { return; }\n\t\tconst helpers = Object.keys(schema.helpers);\n\t\thelpers.forEach((h) => {\n\t\t\t// if (typeof schema.helpers[h] === 'function') {\n\t\t\t//\tBase.prototype.helpers[h] = schema.helpers[h];\n\t\t\t// }\n\t\t\t// create a function from the array\n\t\t\tBase.prototype.helpers[h] = new Function(...schema.helpers[h]);\n\t\t});\n\t};\n\t\n\t// return the NPC object of constructors and the registerSchema function\n\treturn {\n\t\tNPC: NPC,\n\t\tregisterSchema: registerSchema\n\t};\n};\n"]}